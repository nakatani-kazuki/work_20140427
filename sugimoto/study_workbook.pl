#!/usr/local/bin/perl
use strict;

=pod
# 問題1
# ↓の配列の中で一番大きい数字のみを出力
my @array = (1,5,3,8,90,8,77,44,100);

# 1. List::Utilを使う場合
use List::Util qw/max/;
my $max = max @array;
# max @配列　でその配列から最大値を取り出す
print "$max", "\n";

→これは１００点

# 2. 手動でやる場合
my @sorted = sort {$a <=> $b} @array;
print "$sorted[-1]","\n";
# $配列[-1] で配列の最後にアクセスできる。この数字を買えてくと逆順でアクセスできる。

-------------------------------
my @sorted = sort {$b <=> $a} @array;
で逆順にソートできるけえそのあと
print "$sorted[0]" . "\n";
とかのほうが自然かな
何番目の要素かが不明確になるから逆順アクセスはあんまり使わない

一番最後の要素のアクセスするときは
print "$sorted[$#sorted]\n";
って書く場合が多い
多分こっちのほうが明示的に「最後の要素」っていうのがわかりやすいから
-------------------------------



# 問題2
# 30回のloopの中で3の倍数の時はaho、それ以外の時は該当する数字をprintする

# my $x = 1;
# while ($x <= 30){
# 	my $y = $x%3;
# 	if ($y < 1){
# 		print "aho", "\n";
# 	}
# 	else{
# 		print "$x", "\n";
# 	}
# 	$x ++;
# }

-------------------------------
loopは基本的にforを使う
理由はwhileだと条件文の中が真の場合は永遠に回り続けるからとかだと思う
↑の例で行くと実行時に$x++;を書くのを忘れとると無限地獄
あと$xは$iって書くことが多い。多分indexのi。

print "aho", "\n";  ->   print "aho" . "\n";
文字列の連結は「,」じゃなくて「.」
こういうの謎なバグの温床になるけえデバッグでハマるよ！
これでも動いとるのはおそらくprintが複数の引数を受け取ってくれとるから。

print "aho" , "\n";    ->     print($a , $b);
print "aho" . "\n";    ->     print($a);
わかりやすく言うと↑みたいな違いで動いとる
ギリギリじゃぞ！！！！

if ($y < 1){
この書き方だとここではありえんけどマイナスの値とかも許容してしまうことになるから
変数として他で使うことが無いなら計算結果を直接条件文で判定する感じのほうがええかも
if ($x % 3 == 0){
みたいに

$x%3;   ->   $x % 3;
↑スペースあけろおおおおおおおお！！！

print "aho", "\n";     ->    print 'aho', "\n";
細かいけど"aho"は展開する必要がねえからシングルクォーテーションで大丈夫
ahoは展開したところでどのみちaho
※深い意味はないよ

$x ++;  -> $x++;
++に関してはひっつけて書くことが多い
何を+1しとるかってのが複雑な式の中でもわかるようにとかだと思う
my $result = $x ++ + $y++;
って書いとると「$x ++」が意図的なんかほんまは
my $result = $x + $y++;
って書きたかったんかがわかりにくいとか

俺だったらこんな感じで書く

＜例１＞
my $loop_num = 30;
my $div = 3;

for my $num (1..$loop_num) {
	# 割り切れたらaho
	if ($num % $div == 0) {
		print "aho". "\n";
	}
	# それいがいは真面目
	else {
		print "$x" . "\n";
	}
}

・設定を変数として一箇所にまとめとくと後で変更するときに探す手間が省けて楽じゃからそういう癖をつけたほうがええ
・条件文だけではなんでそういう処理にしとるんかわからんて時はコメントを書くほうがええ(他の人が見た時にわかるように)
・コメントの書き方もプログラミングする上では結構大事じゃから今から意識しとくとええで



＜例２（三項演算子使うなら）＞
my $loop_num = 30;
my $div = 3;

for my $num (1..$loop_num) {
	my $word = ($num % $div == 0) ? 'aho' : $x;
	print $word . "\n";
}

・シンプルに書ける
・三項演算子は使ったことないと思うけど便利で読みやすくなるから覚えるとええかも
	↑の場合だと()の中が条件文で、真の場合は「：」の左の値、儀の場合は「：」の右の値が$wordに入る


解説でわからんとこあったらきいてー

-------------------------------

# 問題3
# オリンピックの開催年と何回目かを出力
=pod
第1回は1896年(アテネ)。
第6回(1916年:ベルリン)は第一次世界大戦により開催されなかった。
第12回(1940年:ヘルシンキ), 第13回(1944年:ロンドン)は第二次世界大戦により開催されなかった。
開催されなかった年は出力しないこと。
開催されなかった場合もオリンピアードの回数はカウントされる


my $year;
my $olympic_num = 1;
my $current_year = 2014;

for ($year = 1896 ; $year < $current_year ; $year += 4) {
	# 開催されなかった年を省く
	if ($year == 1916 or $year == 1940 or $year == 1944) {
		$olympic_num++;
	}
	# 上記以外の、開催された年を表示する
	else {
		print "第" . "$olympic_num" . "回" . "\t" . "$year" . "年". "\n";
		$olympic_num++;
	}
}


# my @skiped_year = (1916 , 1940 , 1944);
# my $year = 1896;
# my $current_year = 2014;

# for my $olympic_num(1..30) {
# 	if (!grep { $year == $_ } @skiped_year ){
# 		#grepして、skipped_yearに合致しない場合は0が返ってくるから、それを否定（!)して1にする。と、ifの中身が実行される。
# 		print "第" . "$olympic_num" . "回" . "\t" . "$year" . "年". "\n";
# 	}
# 	$year += 4;
# 	#開催回数（$olympic_num)が1増えるたび（＝ループごと）に4年増えるので。
# 	last if ($year >= $current_year);
# }

grep
grep { $比べたいもの == $_ } @配列
　　　　				↑ここに配列の中身がひとつずつ入って、左の比べたいものと合致するかどうかを調べてくれる
返り値は
$hoge = grep {}・・　→　合致した要素の個数が入ってくる。（合致するものがない＝0を返すので、この0を「偽」として使える。if文とかで。）
@hoge = grep {}・・　→　合致したものを@hogeに配列として全部放り込んでくれる
my($a , $b) = grep {}・・　→　合致したものを2個まで左側の変数で受け取る
my @array = (1..10);
my $num = 20;


# 問題4
1.各配列を出力(配列単位で改行)
2.各配列の最初の要素だけを出力
3.各配列の3位上の要素が何個あるかを出力

#2で割り切れる数字が含まれるかどうか
my $ret = grep { $_	% 2 == 0 } @array;
print "$ret\n";

#2で割り切れる数を配列にする
my @array2 = grep { $_	% 2 == 0 } @array;
use Data::Dumper;
print Dumper(\@array2);
# \をつけて（リファレンス）、配列として扱ってね、ということを伝える



my $ginger = +{
	#ハッシュをひとまとまりにして渡すためにリファレンスとして定義している
	1 => +{
			1 => +[1,2,3],
			2 => +[2,3,4],
		},
	2 => +{
			1 => +[4,5,6],
			2 => +[5,6,7],
		},
};

# use Data::Dumper;
# print Dumper($ginger->{XX}->{XXX});
                    #↑ある塊のなかの一階層目のXXにアクセスできる
use Data::Dumper;

for my $key( keys %$ginger ){
	for my $key2( keys %{$ginger->{$key}} ){
		print Dumper($ginger->{$key}->{$key2});
	}
}
=cut

# 問題5
# 以下のハッシュで例のようなグラフを作成
my $graph = +{
	aaa => 5,
	bbb => 2,
	ccc => 1,
	ddd => 9,
	eee => 10,
};

for my $key( sort keys %$graph){
	#↑keysだけだとバラバラになるけど、sortを入れると文字順／数字順によしなに並べてくれる
	print "$key : " ;
	for my $keynum　(1 .. $graph->{$key}){
		print "*";
	}
	print "\n";
}




























